---
subject: 专业课843
chapter: 计算机组成原理
mastery: 0
next-review: 2026-03-05
status: 未开始
created: 2026-02-27
---

# 存储器层次结构

## 一、存储器分类

### 按位置分类

- **内存（主存）**：CPU 可直接访问，速度快，容量小，断电丢失
- **外存（辅存）**：CPU 不能直接访问，需 IO 操作，速度慢，容量大，断电保留

### SRAM vs DRAM 对比表

| 特性 | SRAM | DRAM |
|------|------|------|
| 存储原理 | 触发器（双稳态） | 电容（电荷） |
| 访问速度 | 快（纳秒级） | 慢（几十纳秒） |
| 集成度 | 低 | 高 |
| 价格 | 贵 | 便宜 |
| 功耗 | 大 | 小 |
| 刷新 | 不需要 | 需要定时刷新 |
| 用途 | Cache（高速缓存） | 主存（内存条） |

### RAM vs ROM 类型

| 类型 | 可写 | 断电 | 说明 |
|------|------|------|------|
| SRAM | 是 | 丢失 | 静态随机存储器 |
| DRAM | 是 | 丢失 | 动态随机存储器 |
| ROM | 否 | 保留 | 只读存储器（厂家固化） |
| PROM | 一次 | 保留 | 可编程只读 |
| EPROM | 可擦写 | 保留 | 紫外线擦除 |
| EEPROM | 电可擦写 | 保留 | 按字节擦除 |
| Flash | 电可擦写 | 保留 | 按块擦除，SSD 核心 |

---

## 二、Cache ★★★ 高频

### 局部性原理

- **时间局部性**：最近访问过的数据，近期还会被访问（循环体、热点数据）
- **空间局部性**：访问某地址后，其附近地址很可能被访问（数组、顺序执行）

> Cache 的有效性就建立在局部性原理之上

### Cache 与主存的地址映射方式

#### 直接映射（Direct Mapped）

$$\text{Cache行号} = \text{主存块号} \mod C \quad (C = \text{Cache总行数})$$

地址结构：
$$\underbrace{标记(Tag)}_{\text{高位}} \mid \underbrace{Cache行号(Index)}_{\text{中位}} \mid \underbrace{块内偏移(Offset)}_{\text{低位}}$$

- 优点：硬件简单，速度快
- 缺点：冲突率高（多个主存块映射到同一Cache行，相互替换——抖动）
- 标记位数 = 主存块号位数 - Cache行号位数

#### 全相联映射（Fully Associative）

主存中任意一块可以放入 Cache 的任意行。

地址结构：
$$\underbrace{标记(Tag)}_{\text{高位（= 主存块号）}} \mid \underbrace{块内偏移(Offset)}_{\text{低位}}$$

- 优点：冲突率最低，Cache 利用率最高
- 缺点：每次查找需要与所有 Cache 行比较，硬件成本高（CAM 内容寻址存储器）

#### 组相联映射（Set Associative）

$n$ 路组相联：Cache 分为若干组，每组 $n$ 行；主存块先按直接映射选组，组内全相联。

$$\text{Cache组号} = \text{主存块号} \mod G \quad (G = \text{Cache组数})$$

地址结构：
$$\underbrace{标记(Tag)}_{\text{高位}} \mid \underbrace{组号(Set)}_{\text{中位}} \mid \underbrace{块内偏移(Offset)}_{\text{低位}}$$

- 直接映射 = 1路组相联；全相联 = m路组相联（m = Cache总行数）
- 4路/8路组相联是实际CPU中最常用的折中方案

#### 三种映射对比

| | 直接映射 | 组相联（n路） | 全相联 |
|--|----------|--------------|--------|
| 冲突率 | 高 | 中 | 最低 |
| 硬件复杂度 | 低 | 中 | 高 |
| 灵活性 | 低 | 中 | 高 |
| 查找时间 | 快 | 中 | 慢 |

### 替换策略

| 策略 | 说明 | 特点 |
|------|------|------|
| LRU（最近最少使用） | 替换最长时间未被访问的行 | 命中率最高，需要时间戳 |
| FIFO（先进先出） | 替换最早进入 Cache 的行 | 简单，但可能出现 Belady 异常（注意！Cache中不会，只在虚存中出现） |
| 随机（Random） | 随机选一行替换 | 最简单，命中率低 |
| LFU（最少使用） | 替换访问次数最少的行 | 需要计数器 |

### 写策略

#### 写命中（Write Hit）

| 策略 | 说明 | 一致性 | 性能 |
|------|------|--------|------|
| **写回法（Write Back）** | 只写 Cache，块被替换时才写主存 | 可能不一致（需脏位 dirty bit） | 高 |
| **全写法（Write Through）** | 同时写 Cache 和主存 | 始终一致 | 低（每次写都访问主存） |

#### 写不命中（Write Miss）

| 策略 | 说明 | 配合 |
|------|------|------|
| **写分配法（Write Allocate）** | 先装入 Cache 再写 | 配合写回法 |
| **非写分配法（No-Write Allocate）** | 直接写主存，不装入 Cache | 配合全写法 |

### Cache 命中率与访问时间

$$t_{avg} = h \times t_c + (1-h) \times t_m$$

其中：
- $h$ = 命中率
- $t_c$ = Cache 访问时间
- $t_m$ = 主存访问时间（不命中时需额外访问主存）

> 注意：有些题目的 $t_m$ 是主存**总**访问时间，有些是主存**额外**访问时间，需看清题意

**另一种公式**（先访问Cache，不命中再访问主存）：

$$t_{avg} = t_c + (1-h) \times t_m$$

---

## 三、主存

### 芯片扩展

设主存需要 $M$ 个地址、每个地址 $W$ 位，现有芯片每片 $m$ 个地址、每片 $w$ 位：

- **位扩展**：并联多片，增加字长（数据位数）
  - 需要的芯片数 $= W/w$，每片共用地址线和片选线
- **字扩展**：串联（片选区分），增加地址数
  - 需要的芯片数 $= M/m$，高位地址线接译码器作片选
- **字位同时扩展**：
  - 总芯片数 $= (M/m) \times (W/w)$

### 存储器地址分配

主存地址线 $n$ 位 $\Rightarrow$ 可寻址 $2^n$ 个单元

按字节编址：每个地址对应 1 字节（8位）

计算芯片数示例：

> 用 $16K \times 8$ 位的 DRAM 芯片组成 $64K \times 32$ 位的主存
> - 字扩展：$64K/16K = 4$ 组
> - 位扩展：$32/8 = 4$ 片/组
> - 总计：$4 \times 4 = 16$ 片

---

## 四、虚拟存储器 ★★★

### 基本概念

- 程序看到的地址 = **虚拟地址（逻辑地址）**
- 实际内存中的地址 = **物理地址**
- 地址变换由 MMU（存储管理单元）负责

### 分页存储

**页（Page）**：逻辑地址空间的等长分区
**帧/页框（Frame）**：物理地址空间的等长分区（大小与页相同）

逻辑地址结构：
$$\underbrace{页号(P)}_{\text{高位}} \mid \underbrace{页内偏移(d)}_{\text{低位}}$$

**页表**：存放逻辑页号到物理帧号的映射，由 OS 维护，存在主存中

页表项字段：帧号 | 有效位 | 修改位 | 访问位 | 保护位

地址变换过程：
1. 逻辑地址 → 页号 $P$ + 偏移 $d$
2. 查页表，得帧号 $F$（若有效位=0，发生缺页中断）
3. 物理地址 $= F \times \text{页大小} + d$

### TLB（Translation Lookaside Buffer）快表

- TLB 是 Cache，存放页表的部分副本，硬件实现，速度接近 Cache
- 命中 TLB：1 次访存（直接得到物理地址，再访问数据 = 共 1 次）

> 实际上地址变换本身不算"访存"，TLB命中后**访问数据需1次访存**；TLB未命中需先查页表（1次访存）再访数据（1次访存）= 共2次访存

**有效访问时间（EAT）**：

设 TLB 命中率 $= h$，TLB 访问时间 $= t_{TLB}$，主存访问时间 $= t_m$

$$EAT = h \times (t_{TLB} + t_m) + (1-h) \times (t_{TLB} + 2t_m)$$

化简：$EAT = t_{TLB} + (2-h) \times t_m$

> 假设 TLB 命中直接得帧号，访问数据 1 次主存；未命中需访问页表 1 次 + 数据 1 次 = 2 次主存

### 页面置换算法

| 算法 | 策略 | 特点 | Belady 异常 |
|------|------|------|-------------|
| **OPT（最优）** | 替换将来最长时间不用的页 | 理论最优，不可实现 | 无 |
| **FIFO** | 替换驻留时间最长的页 | 最简单，但效果差 | 有（增加帧反而缺页增加） |
| **LRU（最近最少使用）** | 替换最近最长时间未访问的页 | 效果好，需要硬件支持 | 无 |
| **Clock（二次机会）** | FIFO + 访问位，访问位为1则给第二次机会置0 | 近似LRU，实现简单 | 无 |
| **改进型Clock** | 考虑访问位+修改位，优先换未修改的页 | 减少写回次数 | 无 |

**Belady 异常**：FIFO 算法中，增加物理帧数反而导致缺页次数增加的现象。LRU 和 OPT 不会出现此异常。

### 多级页表

二级页表：

逻辑地址 $=$ 一级页号 $+$ 二级页号 $+$ 偏移

- 解决单级页表占用内存过大的问题（按需分配二级页表）
- 访问次数 = $n+1$（$n$ 级页表需 $n$ 次查表 + 1 次数据访问），不算 TLB

---

## 五、高频错误 ❌

1. **SRAM 不需要刷新**，DRAM 需要定时刷新（电容放电）；刷新期间 CPU 不能访问主存（死时间）
2. **全写法（Write Through）**每次写命中都写主存，性能较低；**写回法（Write Back）**不是"每次写回主存"，而是替换时才写回
3. **TLB 命中时**：总访存次数 = 1（只访问数据），而不是 0 或 2；TLB未命中 = 2次（先查页表，再读数据）
4. **Belady 异常只发生在 FIFO** 算法，LRU 和 OPT 不会出现；同样，Cache 的替换策略不会出现 Belady 异常
5. **Cache 地址中的"组号/行号"选哪些位**：始终是从块内偏移往高位数，然后是组/行号，最高位是标记；不要把顺序弄反

---

## 公式快查

$$t_{avg} = h \cdot t_c + (1-h) \cdot t_m \quad \text{(Cache 平均访问时间)}$$

$$EAT = t_{TLB} + (2-h) \cdot t_m \quad \text{(TLB 有效访问时间)}$$

$$\text{总芯片数} = \frac{M}{m} \times \frac{W}{w} \quad \text{(字位同时扩展)}$$

$$\text{直接映射行号} = \text{主存块号} \mod C$$

$$\text{组相联组号} = \text{主存块号} \mod G$$

---

## 相关链接

- [[00-组成原理MOC]]
- [[01-数据表示与运算]]
- [[03-指令系统]]
- [[04-CPU与流水线]]
- [[05-总线与IO]]
- [[错题汇总-计算机组成原理]]
