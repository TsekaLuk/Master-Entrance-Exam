---
subject: 专业课843
chapter: 数据结构
mastery: 0
next-review: 2026-03-05
status: 未开始
created: 2026-02-27
---

# 图

## 一、图的基本概念

**有向图**：弧（arc）有方向，弧的出发端称**弧尾（tail）**，到达端称**弧头（head）**。

**无向图**：边（edge）无方向，$(u,v)$ 与 $(v,u)$ 是同一条边。

**完全图边数**：
- 无向完全图（任意两顶点间有边）：$\dfrac{n(n-1)}{2}$ 条边
- 有向完全图（任意两顶点间有两条弧）：$n(n-1)$ 条弧

**度/入度/出度**：
- 无向图中顶点的度 = 与该顶点相连的边数
- 有向图中顶点的**入度**（$ID$）= 以该顶点为弧头的弧数；**出度**（$OD$）= 以该顶点为弧尾的弧数
- 重要性质：$\sum ID = \sum OD = |E|$（有向图中，入度之和 = 出度之和 = 边数）

**路径与回路**：
- **路径**：顶点序列 $v_1, v_2, \ldots, v_k$，相邻顶点间有边
- **简单路径**：路径上所有顶点**不重复**
- **回路/环**：首尾顶点相同的路径
- **简单回路**：除首尾外所有顶点不重复的回路

**连通性**：
- **连通图**（无向）：任意两顶点之间存在路径
- **连通分量**（无向）：极大连通子图（不能再加入新顶点仍保持连通）
- **强连通图**（有向）：任意两顶点 $u, v$，既有 $u \to v$ 的路径，也有 $v \to u$ 的路径
- **强连通分量**（有向）：极大强连通子图

---

## 二、图的存储结构（★★）

### 邻接矩阵

用 $n \times n$ 的二维数组 $A$ 表示：

$$A[i][j] = \begin{cases} 1 & \text{若 } (i,j) \in E \\ 0 & \text{否则} \end{cases}$$

带权图中 $A[i][j]$ 存边权，不存在的边存 $\infty$。

- **空间复杂度**：$O(V^2)$，与边数无关
- **查询某条边**：$O(1)$（直接下标访问）
- **遍历某顶点所有邻居**：$O(V)$（扫描一整行）
- **适合稠密图**（边数接近 $V^2$）

无向图邻接矩阵为**对称矩阵**，可压缩存储。

### 邻接表

每个顶点对应一个链表，链表存该顶点的所有邻居（以及边权）。

- **空间复杂度**：$O(V + E)$
- **遍历某顶点所有邻居**：$O(\text{度数})$
- **判断某条边是否存在**：$O(\text{度数})$（需遍历链表）
- **适合稀疏图**（边数远小于 $V^2$）

有向图中，邻接表只存出边；若需要快速查入边，可另建**逆邻接表**。

### 对比表

| 操作 | 邻接矩阵 | 邻接表 |
|------|---------|--------|
| 空间复杂度 | $O(V^2)$ | $O(V+E)$ |
| 判断边 $(i,j)$ 是否存在 | $O(1)$ | $O(\text{度数})$ |
| 遍历顶点 $v$ 的所有邻居 | $O(V)$ | $O(\text{度数})$ |
| 适用 | 稠密图 | 稀疏图 |

---

## 三、图的遍历（★★）

### BFS（广度优先搜索）

**实现**：用**队列**。从起点出发，将其入队；每次出队一个顶点，访问其所有未访问邻居并入队。

```
BFS(G, s):
    visited[s] = true, enqueue(s)
    while queue not empty:
        u = dequeue()
        for each neighbor v of u:
            if not visited[v]:
                visited[v] = true
                enqueue(v)
```

**时间复杂度**：邻接表 $O(V+E)$，邻接矩阵 $O(V^2)$

**用途**：
- 无权图的**最短路径**（边数最少）
- 层序遍历
- 判断连通性

**BFS 树**：遍历过程中经过的边构成的生成树（树边均为 BFS 发现的新顶点的边）。

### DFS（深度优先搜索）

**实现**：递归（隐式栈）或显式栈。从起点出发，沿一条路径走到底，再回溯。

```
DFS(G, u):
    visited[u] = true
    for each neighbor v of u:
        if not visited[v]:
            DFS(G, v)
```

**时间复杂度**：邻接表 $O(V+E)$，邻接矩阵 $O(V^2)$

**用途**：
- 拓扑排序（DFS 后序逆序）
- 检测有向图中的环
- 求强连通分量（Kosaraju / Tarjan 算法）
- 求无向图的关节点与桥

---

## 四、最小生成树（★★★）

最小生成树（MST）：连通无向图的生成树中，**边权之和最小**的生成树。

### Prim 算法

**思想**：从任意顶点出发，维护一个"已选顶点集合 $S$"，每次选取一条连接 $S$ 与 $V-S$ 的**最小权边**，将对应顶点加入 $S$，直到所有顶点入选。

- **时间复杂度**：$O(V^2)$（朴素实现）；使用优先队列可优化至 $O(E \log V)$
- **特点**：复杂度与**顶点数**有关，与边数无关
- **适合稠密图**

### Kruskal 算法

**思想**：将所有边按权值从小到大排序，依次尝试加入每条边；用**并查集**判断是否成环（加入该边后两端点是否已连通），若不成环则加入 MST，直到已选 $V-1$ 条边。

- **时间复杂度**：$O(E \log E)$（排序主导）
- **特点**：复杂度与**边数**有关，与顶点数无关
- **适合稀疏图**

### 对比表

| | Prim | Kruskal |
|-|------|---------|
| 操作对象 | 顶点 | 边 |
| 时间复杂度 | $O(V^2)$ | $O(E \log E)$ |
| 辅助数据结构 | 优先队列 / 距离数组 | 并查集 |
| 适用图类型 | 稠密图 | 稀疏图 |

> MST 不唯一：当图中有权值相等的边时，MST 可能有多棵（但权值之和相同）。

---

## 五、最短路径（★★★）

### Dijkstra 算法（单源最短路，非负权）

**思想**：维护 $dist[v]$（源点到 $v$ 的当前最短距离），每轮选取 $dist$ 最小的未访问顶点 $u$，对 $u$ 的所有邻居 $v$ 进行**松弛**：

$$\text{if } dist[u] + w(u,v) < dist[v]: \quad dist[v] = dist[u] + w(u,v)$$

- **时间复杂度**：朴素实现 $O(V^2)$；优先队列优化 $O(E \log V)$
- **限制**：**不能处理负权边**（负权边会使已确定的最短路失效）
- 需要处理负权时，改用 Bellman-Ford 算法（$O(VE)$）

### Floyd 算法（多源最短路，可处理负权，不能有负环）

**思想**：动态规划。设 $d[i][j]$ 为 $i \to j$ 经过前 $k$ 个顶点作为中间点的最短路径。

**状态转移**：

$$d[i][j] = \min\bigl(d[i][j],\ d[i][k] + d[k][j]\bigr)$$

对每个中间顶点 $k$ 遍历所有顶点对 $(i, j)$。

- **时间复杂度**：$O(V^3)$
- **空间复杂度**：$O(V^2)$
- 初始化：$d[i][i]=0$，$d[i][j]=w(i,j)$ 若有边，否则 $d[i][j]=\infty$
- 检测负环：若某次迭代后 $d[i][i] < 0$，则存在负环

---

## 六、拓扑排序（★★★）

**AOV 网**（Activity On Vertex）：有向无环图（DAG），顶点表示活动，有向边表示依赖关系。

**拓扑排序算法**：
```
将所有入度为0的顶点入队
while queue not empty:
    u = dequeue()，输出 u
    for each neighbor v of u:
        in_degree[v]--
        if in_degree[v] == 0: enqueue(v)
if 输出顶点数 < V: 图中有环，拓扑序列不存在
```

- **时间复杂度**：$O(V + E)$
- **拓扑序列不唯一**：当队列中同时有多个入度为 0 的顶点时，选择不同顶点会产生不同序列
- **有向图存在拓扑序列 $\Leftrightarrow$ 图是 DAG（无环）**

---

## 七、关键路径（★★）

**AOE 网**（Activity On Edge）：带权有向无环图，**边**表示活动（权值为活动持续时间），**顶点**表示事件（前驱活动全部完成的时间点）。

**关键路径**：从源点到汇点的**最长路径**，决定整个工程的最短完成时间。

### 计算步骤

**1. 事件的最早发生时间 $ve[i]$**（从源点正向计算，取最大值）：
$$ve[j] = \max_{(i,j) \in E} \bigl\{ve[i] + w(i,j)\bigr\}$$
初始：$ve[\text{源点}] = 0$

**2. 事件的最迟发生时间 $vl[i]$**（从汇点反向计算，取最小值）：
$$vl[i] = \min_{(i,j) \in E} \bigl\{vl[j] - w(i,j)\bigr\}$$
初始：$vl[\text{汇点}] = ve[\text{汇点}]$

**3. 活动 $a_k$（对应边 $\langle i, j \rangle$，权值 $w$）的时间参数**：
- 最早开始时间：$e(k) = ve[i]$
- 最迟开始时间：$l(k) = vl[j] - w$
- 松弛时间（时间余量）：$l(k) - e(k)$

**关键活动**：$e(k) = l(k)$，即松弛时间为 0 的活动。

**关键路径** = 由关键活动组成的从源到汇的完整路径。

> 关键路径可能有多条（所有满足条件的最长路径都是关键路径）。缩短工期必须同时缩短所有关键路径上的关键活动。

---

## 八、高频错误

- Dijkstra 能处理负权边：**不能**，负权边会导致已确定最短路的顶点被再次更新，结果错误，需改用 Bellman-Ford。
- 关键路径只有一条：**可能有多条**，所有最长路径（且由关键活动组成的路径）都是关键路径。
- 拓扑排序结果唯一：**不唯一**，同一时刻有多个入度为 0 的顶点时，选择不同顶点将产生不同的拓扑序列。
- Prim 与 Kruskal 复杂度混淆：Prim 是 $O(V^2)$（适合稠密图），Kruskal 是 $O(E \log E)$（适合稀疏图）。
- 连通分量与强连通分量混淆：连通分量针对**无向图**，强连通分量针对**有向图**；求强连通分量需使用 Kosaraju 或 Tarjan 算法，而非普通 DFS。
- Floyd 能处理负权但不能有负环：负环会使最短路径为 $-\infty$，算法不终止。

---

## 公式快查

| 算法 | 时间复杂度 | 适用场景 |
|------|-----------|---------|
| BFS / DFS（邻接表）| $O(V+E)$ | 图的遍历 |
| BFS / DFS（邻接矩阵）| $O(V^2)$ | 图的遍历 |
| Prim（朴素）| $O(V^2)$ | 稠密图 MST |
| Kruskal | $O(E \log E)$ | 稀疏图 MST |
| Dijkstra（朴素）| $O(V^2)$ | 单源最短路（非负权）|
| Dijkstra（优先队列）| $O(E \log V)$ | 单源最短路（非负权）|
| Floyd | $O(V^3)$ | 多源最短路（可负权，无负环）|
| 拓扑排序 | $O(V+E)$ | DAG 活动依赖排序 |
| 关键路径 | $O(V+E)$ | AOE 网工程调度 |

---

## 相关链接

- [[02-科目/专业课/知识点/技术/数据结构/00-数据结构MOC|00-数据结构MOC]]
- [[02-科目/专业课/知识点/技术/数据结构/01-线性结构|01-线性结构]]（BFS用队列，DFS用栈）
- [[02-科目/专业课/知识点/技术/数据结构/04-树与二叉树|04-树与二叉树]]（图的BFS类似树层序）
- [[02-科目/专业课/知识点/技术/数据结构/06-查找|06-查找]]（并查集用于Kruskal）
- [[02-科目/专业课/错题/错题汇总|错题汇总]]
