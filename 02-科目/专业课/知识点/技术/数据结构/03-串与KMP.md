---
subject: 专业课843
chapter: 数据结构
mastery: 0
next-review: 2026-03-05
status: 未开始
created: 2026-02-27
---

# 串与KMP

## 一、串的基本概念

**串（String）**：零个或多个字符组成的有限序列，记作 $S = "a_1 a_2 \ldots a_n"$，$n$ 为串的长度。

**子串**：串中任意个连续字符组成的子序列。主串中子串第一个字符的位置称为子串在主串中的**位置**（下标）。

**主串**：包含子串的串。

**空串**：长度为 0 的串，记作 $\varepsilon$（或 `""`）。注意与**空格串**区分——空格串含有一个或多个空格字符，长度不为 0。

> 约定：空串是任何串的子串（包括空串本身）；任何串是其自身的子串。

**子串个数公式**：长度为 $n$ 的串，子串个数（含空串，不计重复）为：
$$\frac{n(n+1)}{2} + 1$$

**串的存储方式**：

| 方式 | 说明 | 特点 |
|------|------|------|
| 定长顺序存储 | 静态字符数组，长度上限固定 | 简单，超长截断，不灵活 |
| 堆分配存储 | `malloc` 动态分配，`length` 字段记录长度 | 灵活，需手动管理内存 |
| 块链存储 | 每个结点存若干字符（块），结点间用指针链接 | 适合大串，存储密度可调 |

---

## 二、暴力匹配（BF 算法）

**算法思路**：主串指针 $i$，模式串指针 $j$，逐字符比较；失配时 $i$ 回退至本轮起始位置的下一位，$j$ 归零重新匹配。

**伪代码**：
```
i = 0, j = 0
while i < n and j < m:
    if s[i] == p[j]:
        i++, j++
    else:
        i = i - j + 1   // 主串回退
        j = 0
if j == m:
    return i - m        // 匹配成功，返回起始位置
else:
    return -1
```

**时间复杂度**：
- 最好情况：$O(n)$（每轮第一个字符就失配，直到找到匹配）
- 最坏情况：$O(n \times m)$（如主串 `"aaaaab"`，模式串 `"aaab"`）

---

## 三、KMP 算法（★★★ 高频必考）

### 核心思想

利用已匹配信息，**主串指针 $i$ 不回退**，失配时只将模式串指针 $j$ 移动到 $next[j]$ 位置继续比较。

### next 数组定义

$$next[j] = \begin{cases} -1 & j = 0 \\ \max\{k \mid 0 < k < j,\ p[0..k-1] = p[j-k..j-1]\} & \text{最长相等真前后缀长度} \\ 0 & \text{不存在时} \end{cases}$$

即：$next[j]$ 等于模式串 $p[0..j-1]$ 的**最长相等真前后缀**的长度（前缀不含最后一个字符，后缀不含第一个字符）。

### next 数组手算（以 `"abaabcac"` 为例）

逐位分析前缀子串的最长相等真前后缀：

| $j$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|-----|---|---|---|---|---|---|---|---|
| $p[j]$ | a | b | a | a | b | c | a | c |
| 前缀子串 | — | "a" | "ab" | "aba" | "abaa" | "abaab" | "abaab c" | "abaabca" |
| 最长相等真前后缀 | — | 无 | 无 | "a" | "a" | "ab" | 无 | "a" |
| $next$ | **-1** | **0** | **0** | **1** | **1** | **2** | **0** | **1** |

**手算步骤口诀**：
1. $next[0] = -1$，$next[1] = 0$（单字符无真前后缀）
2. 对 $j \geq 2$，观察 $p[0..j-1]$ 中最长相等真前后缀的长度即为 $next[j]$
3. 前缀不含 $p[j-1]$，后缀不含 $p[0]$

### KMP 匹配流程

```
i = 0, j = 0
while i < n and j < m:
    if j == -1 or s[i] == p[j]:
        i++, j++
    else:
        j = next[j]     // 主串i不动，模式串j跳转
if j == m:
    return i - m
else:
    return -1
```

**时间复杂度**：$O(n + m)$（匹配 $O(n)$ + 构建 next 数组 $O(m)$）

---

## 四、nextval 数组（改进 KMP）

### 问题背景

当失配位置满足 $p[j] = p[next[j]]$ 时，跳转到 $next[j]$ 仍会与同一字符比较，产生**无效比较**。

### nextval 计算规则

$$nextval[j] = \begin{cases} -1 & j = 0 \\ next[j] & p[j] \neq p[next[j]] \\ nextval[next[j]] & p[j] = p[next[j]] \end{cases}$$

### 对比表（以 `"abaabcac"` 为例）

| $j$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|-----|---|---|---|---|---|---|---|---|
| $p[j]$ | a | b | a | a | b | c | a | c |
| $next$ | -1 | 0 | 0 | 1 | 1 | 2 | 0 | 1 |
| $nextval$ | -1 | 0 | -1 | 1 | 0 | 2 | -1 | 1 |

**计算过程**（以 $j=2$ 为例）：$p[2]='a'$，$next[2]=0$，$p[0]='a'$，因 $p[2]=p[next[2]]$，故 $nextval[2]=nextval[0]=-1$。

---

## 五、高频错误

- next 数组起始下标：王道书从 **1** 开始（$next[1]=0$），部分教材从 **0** 开始（$next[0]=-1$），做题注意版本，本文统一使用从 **0** 开始的定义。
- KMP 时间复杂度是 $O(n+m)$，**不是** $O(nm)$；$n$ 是主串长度，$m$ 是模式串长度。
- 最长相等真前后缀**不包含串本身**：前缀不含最后一个字符，后缀不含第一个字符。
- nextval 的计算**必须依赖 next 数组**，不能独立直接推导。
- 空串是任何串的子串，这是**约定**，不是推导结论。
- 子串与子序列的区别：子串要求字符**连续**，子序列不要求连续。

---

## 公式快查

| 指标 | BF算法 | KMP算法 |
|------|--------|---------|
| 最坏时间复杂度 | $O(n \times m)$ | $O(n + m)$ |
| 最好时间复杂度 | $O(n)$ | $O(n + m)$ |
| 主串指针回退 | 是 | 否 |
| 预处理 | 无 | next数组 $O(m)$ |
| 空间复杂度 | $O(1)$ | $O(m)$ |

---

## 相关链接

- [[02-科目/专业课/知识点/技术/数据结构/00-数据结构MOC|00-数据结构MOC]]
- [[02-科目/专业课/知识点/技术/数据结构/04-树与二叉树|04-树与二叉树]]（字符串匹配用于Trie树）
- [[02-科目/专业课/错题/错题汇总|错题汇总]]
