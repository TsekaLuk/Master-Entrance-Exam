---
subject: 专业课843
chapter: 计算机组成原理
mastery: 0
next-review: 2026-03-05
status: 未开始
created: 2026-02-27
---

# 指令系统

## 一、指令格式

### 基本结构

$$\underbrace{\text{操作码（OP）}}_{\text{做什么}} \quad \underbrace{\text{地址码（Addr）}}_{\text{对谁做}}$$

- **操作码**：指明指令类型（加、减、存、取、跳转等）
- **地址码**：给出操作数地址或操作数本身

### 指令长度 vs 机器字长

- **指令字长**：一条指令所占的二进制位数
- **机器字长**：CPU 一次能处理的数据位数（= 通用寄存器位数）
- 两者不一定相等：指令字长可以是机器字长的 1/2、1、2 倍（半字长/单字长/双字长指令）
- **定长指令**：所有指令等长，简化译码，RISC 常用
- **变长指令**：指令长度可变，提高编码密度，CISC 常用

### 按地址码个数分类

| 类型 | 格式 | 说明 | 适用场景 |
|------|------|------|----------|
| 零地址 | OP | 不需要地址（HALT、NOP）或操作数在栈中（堆栈机） | 停机、空操作 |
| 一地址 | OP A1 | 单操作数（单目运算），或双操作数其中一个隐含在 ACC | 取反、++、-- |
| 二地址 | OP A1, A2 | 最常见，$A1 \leftarrow A1 \text{ OP } A2$，结果覆盖 A1 | 加减乘除 |
| 三地址 | OP A1, A2, A3 | $A3 \leftarrow A1 \text{ OP } A2$，结果存 A3，A1/A2 不破坏 | 高级语言对应 |

### 扩展操作码技术

目的：在指令字长固定的前提下，增加操作码位数同时保留尽量多的地址位。

- 常用操作用短操作码，不常用操作用长操作码
- 例：15/15/15 方案（三地址/二地址/一地址各 15 条）

---

## 二、寻址方式 ★★★

> **有效地址（EA）**：操作数的实际地址

| 寻址方式 | EA 计算 | 访存次数 | 特点 |
|----------|---------|----------|------|
| **立即寻址** | 操作数 $= A$（在指令中） | 0 | 最快，但范围受指令字长限制 |
| **直接寻址** | $EA = A$ | 1 | 简单，寻址范围受地址码位数限制 |
| **间接寻址** | $EA = \text{Mem}[A]$（A处存放EA） | 2（或更多） | 灵活，但速度慢 |
| **寄存器寻址** | $EA =$ 寄存器号（操作数在寄存器中） | 0 | 最快，无需访存 |
| **寄存器间接寻址** | $EA = R_i$（寄存器内容为地址） | 1 | 常用于数组/指针 |
| **基址寻址** | $EA = R_b + A$（基址寄存器 + 形式地址） | 1 | 面向操作系统，支持重定位和多道程序 |
| **变址寻址** | $EA = R_x + A$（变址寄存器 + 形式地址） | 1 | 面向用户，适合处理数组（循环中修改 $R_x$） |
| **相对寻址** | $EA = PC + A$（PC当前值 + 偏移量） | 1 | 用于转移指令，程序浮动性好 |
| **堆栈寻址** | 隐式，操作数在栈顶（SP指向） | 1 | 用于子程序调用、中断 |

### 关键区分：基址 vs 变址

| 特性 | 基址寻址 | 变址寻址 |
|------|----------|----------|
| 修改方 | 程序运行时 OS 修改基址寄存器 | 用户程序修改变址寄存器 |
| 形式地址 A | 相对偏移（不变） | 数组基地址（不变） |
| 变化量 | 基址（程序重定位） | 变址（遍历数组） |
| 目的 | 支持多道程序、内存保护 | 支持循环、数组访问 |

### 相对寻址注意点

- $PC$ 在取指后已经 **+1**（指向下一条指令），因此 $EA = (PC+1) + A$ 或 $EA = \text{下一条指令地址} + A$
- 具体取决于 PC 更新时机（取指时 or 取指后），要看题目说明

### 寻址方式示例

```
指令: LOAD R1, 100(R2)   ; 基址寻址
操作: R1 ← Mem[R2 + 100]

指令: LOAD R1, [R2]       ; 寄存器间接寻址
操作: R1 ← Mem[R2]

指令: JMP PC+offset       ; 相对寻址
操作: PC ← PC + offset
```

---

## 三、RISC vs CISC

| 特征 | RISC（精简指令集） | CISC（复杂指令集） |
|------|------------------|------------------|
| 代表 | ARM、MIPS、RISC-V | x86、x86-64 |
| 指令数量 | 少（几十条） | 多（几百条） |
| 指令格式 | 定长（如 32 位） | 变长 |
| 寻址方式 | 少（通常 2~3 种） | 多（十几种） |
| 执行周期 | 单周期为主（1 个时钟） | 多周期 |
| 访存指令 | 仅 Load/Store 访存 | 任意指令可访存 |
| 寄存器 | 多（通常 32 个） | 少（如 x86 只有 8 个通用寄存器） |
| 流水线 | 容易实现高效流水线 | 复杂，需微操作分解 |
| 编译器 | 要求高（负担重） | 要求低 |
| 硬件复杂度 | 低 | 高 |
| 代码密度 | 低（指令多） | 高（指令少） |

> **记忆口诀**：RISC = "少精快流"（指令少、格式精简、执行快、易流水）

### 现代 CPU 融合趋势

x86 CPU 在硬件上将 CISC 指令翻译为类 RISC 微操作（micro-ops）执行，兼顾兼容性和性能。

---

## 四、高频错误 ❌

1. **立即寻址的操作数在指令中**，不需要访存，但这也意味着操作数大小受指令字长限制，不能表示任意大的数
2. **基址寻址 vs 变址寻址的修改者**：基址由 OS 修改（用于重定位），变址由用户程序修改（用于数组循环）；题目常考"哪种适合数组处理" → 变址寻址
3. **相对寻址中 PC 的值**：执行转移指令时，PC 已经更新为**下一条**指令的地址（取指后PC自动+1），EA = PC（下条地址）+ 偏移量
4. **访存次数**：间接寻址需要 2 次（先取 EA，再取操作数）；如果多级间接则更多次；不要把"取指"也算进去（通常题目只问操作数的访存次数）

---

## 公式快查

$$EA_{\text{直接}} = A$$
$$EA_{\text{间接}} = \text{Mem}[A]$$
$$EA_{\text{基址}} = R_b + A$$
$$EA_{\text{变址}} = R_x + A$$
$$EA_{\text{相对}} = PC + A \quad \text{(PC 为下条指令地址)}$$

$$\text{操作码位数} = n \Rightarrow \text{最多} 2^n \text{ 条指令}$$

---

## 相关链接

- [[00-组成原理MOC]]
- [[01-数据表示与运算]]
- [[02-存储器层次结构]]
- [[04-CPU与流水线]]
- [[05-总线与IO]]
- [[错题汇总-计算机组成原理]]
