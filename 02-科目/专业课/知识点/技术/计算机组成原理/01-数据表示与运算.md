---
subject: 专业课843
chapter: 计算机组成原理
mastery: 0
next-review: 2026-03-05
status: 未开始
created: 2026-02-27
---

# 数据表示与运算

## 一、进位计数制

### 各进制对照

| 十进制 | 二进制 | 八进制 | 十六进制 |
|--------|--------|--------|----------|
| 0      | 0000   | 0      | 0        |
| 8      | 1000   | 10     | 8        |
| 10     | 1010   | 12     | A        |
| 15     | 1111   | 17     | F        |
| 16     | 10000  | 20     | 10       |

### 互转规则

- **二进制 → 八进制**：从小数点起，每 3 位一组，不足补 0
- **二进制 → 十六进制**：每 4 位一组
- **十进制整数 → 二进制**：除 2 取余，逆序排列
- **十进制小数 → 二进制**：乘 2 取整，顺序排列（可能不精确）

### BCD 码

- 用 4 位二进制表示 1 位十进制数（0000~1001 有效）
- 8421 BCD：权值为 8、4、2、1
- 压缩 BCD：1 字节存 2 位十进制
- 非法码：1010~1111

---

## 二、定点数的表示 ★★★

### 四种编码定义

设机器字长为 $n$ 位（含 1 位符号位），表示数 $x$：

**原码**（Sign-Magnitude）：
$$[x]_原 = \begin{cases} x & 0 \le x < 2^{n-1} \\ 2^{n-1} - x = 2^{n-1} + |x| & -2^{n-1} < x \le 0 \end{cases}$$

**反码**（One's Complement）：
$$[x]_反 = \begin{cases} x & x \ge 0 \\ (2^n - 1) + x & x < 0 \end{cases}$$
> 负数反码 = 原码符号位不变，数值位逐位取反

**补码**（Two's Complement）：
$$[x]_补 = \begin{cases} x & x \ge 0 \\ 2^n + x & x < 0 \end{cases}$$
> 负数补码 = 反码 + 1；或：原码符号位不变，数值位从右往左第一个 1 左边全部取反

**移码**（Excess/Biased）：
$$[x]_移 = 2^{n-1} + x$$
> 移码 = 补码的符号位取反；主要用于浮点数阶码

### 取值范围（n 位，含符号位）

| 编码 | 正数最大 | 负数最小 | 零的表示 |
|------|----------|----------|----------|
| 原码 | $2^{n-1}-1$ | $-(2^{n-1}-1)$ | +0 和 -0 两种 |
| 反码 | $2^{n-1}-1$ | $-(2^{n-1}-1)$ | +0 和 -0 两种 |
| 补码 | $2^{n-1}-1$ | $-2^{n-1}$ | 唯一（全0） |
| 移码 | $2^{n-1}-1$ | $-2^{n-1}$ | 唯一 |

> **补码的范围**：$n$ 位整数 $[-2^{n-1},\ 2^{n-1}-1]$，比原码多表示一个最小负数 $-2^{n-1}$

### 关键结论

- 原码和反码的 0 有两种表示（$+0$ / $-0$），**补码只有一种 0**
- $[-2^{n-1}]_补$ 存在，但 $[-2^{n-1}]_原$ 不存在（溢出）
- 移码全 0 表示 $-2^{n-1}$，全 1 表示 $2^{n-1}-1$
- 补码转原码：再取一次补（负数）

### 转换速记

```
正数：原码 = 反码 = 补码（符号位0，数值不变）
负数：
  原码 → 反码：数值位全部取反
  反码 → 补码：+1
  原码 → 补码：数值位从最低位的1开始，往左全部取反
  补码 → 原码：符号位不变，数值位取反+1（即再取一次补）
```

---

## 三、IEEE 754 浮点数 ★★★

### 通用格式

$$N = (-1)^S \times 1.M \times 2^{E - \text{偏置值}}$$

| 类型 | 总位数 | 符号S | 阶码E | 尾数M | 偏置值 |
|------|--------|-------|-------|-------|--------|
| 单精度 | 32 | 1位 | 8位 | 23位 | 127 |
| 双精度 | 64 | 1位 | 11位 | 52位 | 1023 |

### 字段说明

- **S（符号位）**：0 为正，1 为负
- **E（阶码）**：用移码表示，单精度偏置值 $= 127 = 2^7 - 1$
- **M（尾数）**：规格化时隐含最高位为 1（即实际尾数 $= 1.M$，存储时省略整数位 1）

### 规格化

- 规格化数要求尾数最高有效位为 1，即 $1.0 \le |M| < 2$
- 隐含位 1 不存储，因此 23 位尾数实际表示 24 位精度
- 单精度有效十进制数字约 $\log_{10}2^{24} \approx 7$ 位

### 特殊值（单精度）

| 情况 | 阶码E | 尾数M | 值 |
|------|-------|-------|----|
| 正零 | 全0 | 全0 | $+0$ |
| 负零 | 全0（S=1）| 全0 | $-0$ |
| 正无穷 | 全1 | 全0 | $+\infty$ |
| 负无穷 | 全1（S=1）| 全0 | $-\infty$ |
| NaN | 全1 | 非0 | Not a Number |
| 非规格化数 | 全0 | 非0 | $(-1)^S \times 0.M \times 2^{-126}$ |

### 编解码示例

**十进制 $-0.75$ → 单精度 IEEE 754**：
1. $-0.75 = -3/4 = -1.1_2 \times 2^{-1}$
2. $S = 1$
3. $E = -1 + 127 = 126 = 01111110_2$
4. $M = 1000...0$（23位，隐含整数位1后是 .100...0）
5. 结果：`1 01111110 10000000000000000000000`

**单精度 `0 10000000 10000000000000000000000` → 十进制**：
1. $S = 0$，$E = 10000000_2 = 128$，$M = 1$
2. 真值 $= (+1) \times 1.1_2 \times 2^{128-127} = 1.1_2 \times 2^1 = 11_2 = 3.0$

### 浮点数的范围（单精度）

- 最大正规格化数：$E=11111110$，$M=全1$，约 $3.4 \times 10^{38}$
- 最小正规格化数：$E=00000001$，$M=全0$，约 $1.2 \times 10^{-38}$

---

## 四、运算

### 补码加减法

$$[A+B]_补 = [A]_补 + [B]_补 \pmod{2^n}$$
$$[A-B]_补 = [A]_补 + [-B]_补$$
$$[-B]_补 = [B]_补 \text{ 各位取反} + 1$$

### 溢出检测

**双符号位法（变形补码）**：扩展为 2 位符号位参与运算

| 结果符号位 | 含义 |
|------------|------|
| 00 | 正数，无溢出 |
| 01 | 正溢出（结果超出正数范围） |
| 10 | 负溢出（结果超出负数范围） |
| 11 | 负数，无溢出 |

> 结论：两个符号位**不相同**则发生溢出

**单符号位法**：$V = C_n \oplus C_{n-1}$（最高进位与次高进位异或，1 表示溢出）

### 乘法（Booth 算法思想）

对补码乘法，Booth 算法通过检查相邻两位决定操作：

| $y_i$ | $y_{i-1}$ | 操作 |
|-------|-----------|------|
| 0 | 0 | 部分积右移1位 |
| 0 | 1 | 部分积 + [X]补，右移1位 |
| 1 | 0 | 部分积 + [-X]补，右移1位 |
| 1 | 1 | 部分积右移1位 |

### 除法（恢复余数法思想）

1. 上商 1：若余数 ≥ 0
2. 上商 0 并恢复余数：若余数 < 0
3. 重复直到商足够位数

不恢复余数法（加减交替法）：若余数为负直接加除数（不需恢复），效率更高

### ALU 的基本构成

- 算术逻辑部件：执行加、减、与、或、非、移位
- 进位链：串行进位（慢）→ 先行进位（快，并行进位 CLA）
- 标志位：ZF（零标志）/ SF（符号标志）/ OF（溢出标志）/ CF（进位标志）

---

## 五、高频错误 ❌

1. **移码不是补码**：移码 = 补码符号位取反，两者阶码值不同；移码没有符号位含义
2. **-128 的补码**：8位补码中 $-128$ 为 `10000000`，其**原码不存在**（无法用8位原码表示）
3. **IEEE 754 偏置值**：单精度偏置 127（不是128），全0阶码表示非规格化数或0，全1阶码表示特殊值
4. **隐含位**：规格化浮点数尾数有隐含的整数位 1，精度 = M位数 + 1 位（不是 M 位）
5. **溢出判断**：双符号位 01 是正溢出（两个正数相加超出范围），10 是负溢出（两个负数相加）；不要弄反

---

## 公式快查

$$[x]_补 = 2^n + x \quad (x < 0)$$

$$[-x]_补 = \overline{[x]_补} + 1 \pmod{2^n}$$

$$\text{IEEE 754 真值} = (-1)^S \times 1.M \times 2^{E-127} \quad \text{(单精度)}$$

$$\text{单精度精度位数} = 24 \text{ bits} \approx 7 \text{ 位十进制}$$

$$\text{溢出（双符号位）}: S_{符1} \ne S_{符2} \Rightarrow \text{溢出}$$

---

## 相关链接

- [[00-组成原理MOC]]
- [[02-存储器层次结构]]
- [[03-指令系统]]
- [[04-CPU与流水线]]
- [[05-总线与IO]]
- [[错题汇总-计算机组成原理]]
