---
subject: 专业课843
chapter: 计算机组成原理
mastery: 0
next-review: 2026-03-05
status: 未开始
created: 2026-02-27
---

# CPU 与流水线

## 一、CPU 的组成

### 数据通路

- **ALU（算术逻辑单元）**：执行算术和逻辑运算
- **寄存器组**：暂存操作数、地址、状态信息
- **内部总线（CPU 内部数据通路）**：连接各寄存器和 ALU

### 关键寄存器完整列表

| 寄存器 | 全称 | 作用 |
|--------|------|------|
| **PC** | Program Counter 程序计数器 | 存放下一条要执行指令的地址，自动 +1 |
| **IR** | Instruction Register 指令寄存器 | 存放当前正在执行的指令 |
| **MAR** | Memory Address Register 存储器地址寄存器 | 存放要访问的主存地址，与地址总线相连 |
| **MDR** | Memory Data Register 存储器数据寄存器 | 存放从主存读出或将要写入的数据，与数据总线相连 |
| **PSW** | Program Status Word 程序状态字 | 存放 CPU 状态标志（ZF/SF/OF/CF）和控制位 |
| **ACC** | Accumulator 累加器 | 存放运算结果，单地址指令的隐含操作数 |
| **通用寄存器 R0~Rn** | General Purpose Register | 存放操作数、地址，减少访存次数 |
| **SP** | Stack Pointer 堆栈指针 | 指向当前栈顶地址 |

---

## 二、指令执行周期

### 五阶段划分（现代流水线标准）

```
取指(IF) → 译码(ID) → 执行(EX) → 访存(MEM) → 写回(WB)
```

| 阶段 | 英文 | 主要操作 | 相关寄存器 |
|------|------|----------|------------|
| 取指 IF | Instruction Fetch | PC → MAR → 主存读指令 → MDR → IR；PC+1 | PC、MAR、MDR、IR |
| 译码 ID | Instruction Decode | 对 IR 中操作码译码，读取寄存器文件，计算立即数 | IR、通用寄存器 |
| 执行 EX | Execute | ALU 运算，计算地址（基址/变址/相对） | ALU、PSW |
| 访存 MEM | Memory Access | 对内存读写（仅 Load/Store 指令使用此阶段） | MAR、MDR |
| 写回 WB | Write Back | 将运算结果写回寄存器文件 | 通用寄存器 |

### 中断响应时机

> **重要**：CPU 在**每条指令执行结束后**（完成 WB 后、取下一条指令前）检测中断请求。
> 不是在指令中途响应，不是在流水线每个阶段后响应。

---

## 三、控制器

### 硬布线控制器（组合逻辑控制器）

- 实现方式：用组合逻辑电路（门电路）直接产生控制信号
- 输入：操作码、状态标志、时序信号
- 输出：各种微操作控制信号
- 优点：**速度快**，适合 RISC
- 缺点：设计复杂，**修改困难**，调试难，不规则

### 微程序控制器

- 实现方式：每条机器指令对应一段**微程序**，由微指令序列执行
- **微指令**：存放在控制存储器（Control Store，ROM）中，规定一组微操作
- **微操作**：最基本的不可分割的操作（如：ALU 做加法、PC 加 1、数据从 MDR 到 IR）
- 优点：**规整、灵活、易修改**，适合 CISC
- 缺点：**速度慢**（每个微操作都要访问控制存储器）

### 关系图

```
机器指令 → 取出 → 微程序（多条微指令）
              ↓
         微指令1 → 产生一组微操作控制信号
         微指令2 → 产生一组微操作控制信号
         ...
         微指令n（结束，取下一条机器指令）
```

### 微指令的编码方式

| 方式 | 说明 | 特点 |
|------|------|------|
| 直接编码（水平型） | 每位对应一个微操作控制信号 | 并行度高，微指令字长，控存容量大 |
| 字段直接编码 | 将互斥的微操作分组编码 | 折中，减少字长 |
| 字段间接编码 | 某字段的解释依赖另一字段 | 进一步压缩，但速度慢 |
| 垂直型 | 类似机器指令，操作码+地址 | 字段短，并行度低 |

---

## 四、流水线 ★★★

### 流水线原理

将指令执行分为 $k$ 个阶段，各阶段**并行执行**不同指令的不同阶段。

```
时间：  1   2   3   4   5   6   7
指令1: IF  ID  EX  MEM WB
指令2:     IF  ID  EX  MEM WB
指令3:         IF  ID  EX  MEM WB
指令4:             IF  ID  EX  MEM WB
```

### 流水线性能指标

设共 $n$ 条指令，流水线 $k$ 级，每级时间 $\Delta t$：

**吞吐率（TP）**：

$$TP = \frac{n}{(n+k-1) \cdot \Delta t} \approx \frac{1}{\Delta t} \quad (n \gg k)$$

**加速比（S）**：

$$S = \frac{k \cdot n \cdot \Delta t}{(n+k-1) \cdot \Delta t} = \frac{kn}{n+k-1} \approx k \quad (n \gg k)$$

**效率（E）**：

$$E = \frac{S}{k} = \frac{n}{n+k-1} \approx 1 \quad (n \gg k)$$

> 流水线的加速比接近于流水线的**级数** $k$（理想情况）

### CPI 计算

无冒险时：$CPI = 1$

有停顿时：$CPI = 1 + \frac{\text{停顿周期数}}{n}$

实际执行时间 $= (n + k - 1 + \text{停顿总周期}) \times \Delta t$

### 三类相关与冒险（Pipeline Hazards）

#### 1. 结构相关（结构冒险 / 资源冲突）

**原因**：多条指令在同一周期需要同一硬件资源（如只有一个 ALU、存储器只有一个读口）

**解决方法**：
- 增加硬件资源（资源复制）：如哈佛架构分离指令存储器和数据存储器
- 插入流水线气泡（暂停/stall）

#### 2. 数据相关（数据冒险）

**原因**：后续指令依赖前面指令还未写回的结果

三种类型：
- **RAW（Read After Write）**：先写后读，最常见，真相关
- **WAR（Write After Read）**：先读后写，反相关，乱序执行时出现
- **WAW（Write After Write）**：写后写，输出相关，乱序执行时出现

**RAW 示例**：
```
ADD R1, R2, R3    ; R1 = R2 + R3 （WB 在第5周期）
SUB R4, R1, R5   ; R4 = R1 - R5 （ID 在第3周期就需要 R1）
```

**解决方法**：
- **数据转发（Forwarding/Bypassing）**：将 EX 阶段结果直接转发到下一条指令的 EX 阶段，无需等到 WB
- **流水线暂停（气泡/NOP）**：编译器或硬件插入等待周期
- **指令重排序**：编译器调整指令顺序，将不相关指令填入延迟槽

#### 3. 控制相关（控制冒险 / 分支冒险）

**原因**：遇到转移（分支）指令时，下一条指令地址未知（需等待分支结果）

**解决方法**：
- **分支预测**：
  - 静态预测：总是预测不跳转（预测已发生分支/未发生分支）
  - 动态预测：1位/2位历史预测器，根据历史决定预测方向
- **延迟分支（Delayed Branch）**：RISC 常用，分支指令后的指令（延迟槽）总是执行，编译器负责填充有用指令
- **分支取消**：预测执行，若预测错误则取消已取入的指令

### 超标量与超流水线

| 技术 | 原理 | 性能 |
|------|------|------|
| **超标量（Superscalar）** | 每个时钟周期发射多条指令（多条流水线并行） | CPI < 1 |
| **超流水线（Super-pipelining）** | 增加流水线级数（更细粒度划分），提高时钟频率 | 时钟频率提高 |

---

## 五、中断系统

### 中断处理流程

```
1. 中断源发出中断请求（INTR 信号）
2. CPU 检测中断（指令执行结束后）
3. CPU 关中断（保证响应过程不被打断）
4. 保存断点（将 PC 压栈）
5. 识别中断源（向量中断：查中断向量表；非向量中断：软件查询）
6. 保存现场（保存通用寄存器到栈）
7. 开中断（允许更高优先级中断嵌套）
8. 执行中断服务程序（ISR）
9. 关中断
10. 恢复现场（从栈恢复寄存器）
11. 开中断，中断返回（IRET，恢复 PC）
```

### 中断优先级与嵌套

- 优先级高的中断可以打断优先级低的中断处理（中断嵌套）
- 优先级判断由硬件完成（中断控制器如 8259A）
- 软件通过设置中断屏蔽字来控制中断嵌套

### 中断 vs 异常

| 类型 | 来源 | 时机 | 示例 |
|------|------|------|------|
| 外部中断 | 外设、时钟 | 指令执行后 | 键盘输入、定时器 |
| 内部异常（陷阱 Trap）| 指令执行 | 指令内部 | 系统调用、断点 |
| 内部异常（故障 Fault）| 指令执行 | 指令前/中 | 缺页、除零 |
| 内部异常（终止 Abort）| 硬件错误 | 任意 | 双重故障 |

---

## 六、高频错误 ❌

1. **中断响应时机**：CPU 在**一条指令执行完毕后**才响应中断，不是在指令执行中途，也不是在每个流水线阶段后（流水线中实际在 WB 后、下一个 IF 前检测）
2. **流水线加速比**：加速比 $\approx k$（级数），不是 $k$ 倍执行速度提升，因为有填充时间 $(k-1)\Delta t$ 的开销
3. **数据转发不能解决所有 RAW**：Load-Use 冒险（load 指令后紧跟使用该寄存器的指令）即使有转发也需要 1 个气泡（load 要等到 MEM 才有数据，无法直接转发到下一条的 EX）
4. **微程序控制器存在于控制存储器（ROM）中**，不是主存；修改微程序需要更换 ROM，而不是修改主存内容（EPROM 可以）
5. **WAR / WAW 相关**：不会在顺序执行的简单流水线中出现（因为顺序执行时 Write 总在 Read 之后），只在乱序执行（Out-of-Order）或多发射流水线中才是问题

---

## 公式快查

$$TP = \frac{n}{(n+k-1)\Delta t} \approx \frac{1}{\Delta t}$$

$$S = \frac{kn}{n+k-1} \approx k$$

$$E = \frac{n}{n+k-1} \approx 1$$

$$CPI_{\text{实际}} = 1 + \frac{\text{总停顿周期}}{n}$$

$$\text{执行时间} = (n + k - 1 + \text{停顿}) \times \Delta t$$

---

## 相关链接

- [[00-组成原理MOC]]
- [[01-数据表示与运算]]
- [[02-存储器层次结构]]
- [[03-指令系统]]
- [[05-总线与IO]]
- [[错题汇总-计算机组成原理]]
