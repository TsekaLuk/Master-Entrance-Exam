---
title: 树与二叉树
subject: 专业课843
chapter: 数据结构
status: 未开始
created: 2026-02-26
tags: [知识点, 843, 数据结构, 二叉树, 遍历, 堆, BST]
---

# 树与二叉树

> 843 A3数据结构 | 关联：[[01-线性结构]] · [[03-排序算法]] · [[04-查找算法]]

---

## 一、树的基本术语

| 术语 | 定义 |
|------|------|
| **度（degree）** | 一个节点的子树数量 |
| **树的度** | 所有节点度的最大值 |
| **深度/层数** | 根节点在第1层，依次递增 |
| **高度** | 树中节点的最大层数（与深度同义）|
| **叶子节点** | 度为0的节点（无子节点）|
| **森林** | $m$（$m\ge 0$）棵互不相交的树的集合 |

---

## 二、二叉树性质（必背！）

1. 第 $i$ 层最多 $2^{i-1}$ 个节点（$i\ge 1$）
2. 高度为 $h$ 的二叉树最多 $2^h-1$ 个节点（满二叉树）
3. **$n_0=n_2+1$**：叶子节点数 $=$ 度为2的节点数 $+1$
4. 具有 $n$ 个节点的完全二叉树高度 $=\lceil\log_2(n+1)\rceil$

> **二级结论（性质3的证明思路）**：设边数为 $e$，则 $e=n-1$（树的边数）；又 $e=n_1+2n_2$（每个度为1的节点贡献1条边，度为2贡献2条）；联立 $n=n_0+n_1+n_2$，消去 $n_1$ 得 $n_0=n_2+1$

---

## 三、特殊二叉树

| 类型 | 定义 | 节点数 |
|------|------|--------|
| **满二叉树** | 每个节点度为0或2，且所有叶子在同一层 | $2^h-1$ |
| **完全二叉树** | 除最后一层外均满，最后一层节点靠左排列 | $n$ |

**完全二叉树的数组下标性质**（从1开始编号）：
- 节点 $i$ 的左孩子：$2i$；右孩子：$2i+1$
- 节点 $i$ 的父节点：$\lfloor i/2\rfloor$
- 叶子节点：编号 $>\lfloor n/2\rfloor$ 的节点

---

## 四、遍历（重要！）

| 遍历方式 | 顺序 | 递归实现 | 典型用途 |
|---------|------|---------|---------|
| **前序** | 根→左→右 | `visit, left, right` | 复制树、前缀表达式 |
| **中序** | 左→根→右 | `left, visit, right` | BST升序输出 |
| **后序** | 左→右→根 | `left, right, visit` | 删除树、后缀表达式 |
| **层序** | 按层从左到右 | 用**队列**（→[[01-线性结构]]）| 最短路径、序列化 |

**由遍历序列重建二叉树**：
- 前序+中序 → 唯一确定二叉树
- 后序+中序 → 唯一确定二叉树
- 前序+后序 → **不能**唯一确定（当节点只有一个子节点时有歧义）

> ⚠️ 前序第一个元素/后序最后一个元素 = 根节点；在中序中找根节点位置，递归划分左右子树

---

## 五、二叉搜索树（BST）

**定义**：对每个节点，左子树所有节点 $<$ 根 $<$ 右子树所有节点

**中序遍历 = 升序序列**

| 操作 | 平均复杂度 | 最坏复杂度 |
|------|----------|----------|
| 查找 | $O(\log n)$ | $O(n)$（退化为链表）|
| 插入 | $O(\log n)$ | $O(n)$ |
| 删除 | $O(\log n)$ | $O(n)$ |

> **二级结论（BST退化）**：顺序插入 $n$ 个有序数据会退化为链表，深度 $O(n)$。解决方案：AVL树（平衡二叉树），保证高度 $O(\log n)$

---

## 六、堆（Heap）

**定义**：完全二叉树（→性质满足数组实现），且满足堆序性质

| 类型 | 性质 | 根节点 |
|------|------|--------|
| **最大堆** | 每个节点 $\ge$ 其子节点 | 最大值 |
| **最小堆** | 每个节点 $\le$ 其子节点 | 最小值 |

**基本操作**：
- **建堆**：$O(n)$（从最后一个非叶子节点向上调整）
- **插入**：$O(\log n)$（插入末尾，向上调整 sift-up）
- **删除最大/最小**：$O(\log n)$（交换根与末尾，向下调整 sift-down）

**堆排序利用最大堆完成降序排列** → 详见[[03-排序算法]]

---

## 七、哈夫曼树（最优二叉树）

**目的**：构造带权路径长度（WPL）最小的二叉树

**构造方法**（贪心）：
1. 每次取权值最小的两棵树合并
2. 新树权值 = 两子树权值之和
3. 重复直到只剩一棵树

**应用**：哈夫曼编码（高频字符用短编码，低频用长编码，无前缀冲突）

---

## 公式快查

| 结论 | 公式 |
|------|------|
| 叶子节点数 | $n_0=n_2+1$ |
| 完全二叉树高度 | $\lceil\log_2(n+1)\rceil$ |
| 数组左孩子 | $2i$ |
| 数组右孩子 | $2i+1$ |
| 数组父节点 | $\lfloor i/2\rfloor$ |
| 建堆 | $O(n)$ |

---

## 相关链接
- [[02-科目/专业课/知识点/技术/数据结构/01-线性结构|01-线性结构]]（层序遍历使用队列）
- [[02-科目/专业课/知识点/技术/数据结构/03-排序算法|03-排序算法]]（堆排序 = 堆 + 排序）
- [[02-科目/专业课/知识点/技术/数据结构/04-查找算法|04-查找算法]]（BST是搜索结构）
- [[02-科目/专业课/错题/错题汇总|错题汇总]]
